Phase 2: Associative Recall & Contradiction Detection (Months 4-6)
Goal
Enable Bliss to surface relevant past insights automatically and gently point out self-contradictions.
2.1 Associative Recall System
What It Does:

Automatically brings up relevant past conversations
Connects ideas across time and contexts
Creates "aha!" moments by linking distant memories

Architecture:
typescript// server/services/associativeRecallService.ts

export class AssociativeRecallService {
  // Find memories associated with current context
  async recall(
    userId: string,
    currentMessage: string,
    conversationHistory: Message[]
  ): Promise<RecalledMemory[]> {
    
    // 1. Semantic similarity search
    const semanticallyRelated = await this.findSimilarMemories(
      userId, 
      currentMessage
    );

    // 2. Temporal patterns (similar time of day, day of week, season)
    const temporallyRelated = await this.findTemporalMatches(
      userId,
      new Date()
    );

    // 3. Emotional resonance (similar emotional state)
    const currentEmotion = await emotionalAnalysisService.analyzeEmotion(
      currentMessage
    );
    const emotionallyRelated = await this.findEmotionalMatches(
      userId,
      currentEmotion
    );

    // 4. Theme/topic overlap
    const currentThemes = await this.extractThemes(currentMessage);
    const thematicallyRelated = await this.findThemeMatches(
      userId,
      currentThemes
    );

    // 5. Growth phase alignment
    const currentPhase = await this.detectGrowthPhase(
      userId,
      conversationHistory
    );
    const phaseRelated = await this.findPhaseMatches(
      userId,
      currentPhase
    );

    // Combine and rank by relevance
    const allRecalls = this.combineAndRank([
      ...semanticallyRelated,
      ...temporallyRelated,
      ...emotionallyRelated,
      ...thematicallyRelated,
      ...phaseRelated
    ]);

    // Filter to most relevant (top 3)
    return allRecalls.slice(0, 3);
  }

  private async findSimilarMemories(
    userId: string,
    query: string
  ): Promise<RecalledMemory[]> {
    const queryEmbedding = await this.generateEmbedding(query);
    
    const results = await db.execute(sql`
      SELECT 
        m.*,
        1 - (m.embedding <=> ${queryEmbedding}) as similarity,
        EXTRACT(EPOCH FROM (NOW() - m.created_at)) / 86400 as days_ago
      FROM memories m
      WHERE m.user_id = ${userId}
        AND 1 - (m.embedding <=> ${queryEmbedding}) > 0.7
      ORDER BY similarity DESC
      LIMIT 10
    `);

    return results.map(r => ({
      memory: r,
      relevanceScore: r.similarity * (1 / (1 + Math.log(r.days_ago + 1))),
      recallType: 'semantic'
    }));
  }

  private combineAndRank(recalls: RecalledMemory[]): RecalledMemory[] {
    // Group by memory ID (same memory may appear via multiple paths)
    const memoryMap = new Map<string, RecalledMemory>();
    
    for (const recall of recalls) {
      const existing = memoryMap.get(recall.memory.id);
      if (existing) {
        // Boost score if memory found through multiple pathways
        existing.relevanceScore += recall.relevanceScore * 0.5;
        existing.recallTypes.push(recall.recallType);
      } else {
        memoryMap.set(recall.memory.id, {
          ...recall,
          recallTypes: [recall.recallType]
        });
      }
    }

    // Sort by relevance, prioritizing multi-pathway recalls
    return Array.from(memoryMap.values())
      .sort((a, b) => {
        const aBoost = a.recallTypes.length > 1 ? 1.5 : 1;
        const bBoost = b.recallTypes.length > 1 ? 1.5 : 1;
        return (b.relevanceScore * bBoost) - (a.relevanceScore * aBoost);
      });
  }

  async generateEmbedding(text: string): Promise<number[]> {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: text
    });
    return response.data[0].embedding;
  }
}
Integration with Chat:
typescript// server/routes/chat.ts

router.post('/api/chat/stream', async (req, res) => {
  const { message, conversationId } = req.body;
  const userId = req.user.id;

  // Get associative recalls
  const recalls = await associativeRecallService.recall(
    userId,
    message,
    conversationHistory
  );

  // Build enhanced context for Bliss
  const enhancedContext = `
Current message: ${message}

Relevant memories to consider:
${recalls.map((r, i) => `
${i + 1}. From ${formatDate(r.memory.createdAt)} (${r.memory.memoryType}):
   "${r.memory.content}"
   [Recalled via: ${r.recallTypes.join(', ')}]
`).join('\n')}

Instructions: Naturally reference these memories if relevant. Don't force it.
Use phrases like:
- "I remember when you mentioned..."
- "This reminds me of what you shared about..."
- "You've explored this before when you were..."
`;

  // Generate response with enhanced context
  const stream = await openai.chat.completions.create({
    model: "gpt-4",
    messages: [
      { role: "system", content: BLISS_SYSTEM_PROMPT + enhancedContext },
      ...conversationHistory,
      { role: "user", content: message }
    ],
    stream: true
  });

  // Stream response to client
  for await (const chunk of stream) {
    res.write(`data: ${JSON.stringify(chunk)}\n\n`);
  }
  res.end();
});
Example User Experience:
User: "I'm thinking about quitting my job."

Bliss: "That's a significant decision. I remember three months ago 
you were feeling similarly frustratedâ€”you mentioned feeling 
unfulfilled and wanting more creative freedom. You were exploring 
freelance design work at the time. Is this feeling similar, or has 
something new shifted for you?"
Success Metrics:

Recall relevance: >70% of recalls deemed helpful by users
Natural integration: Users don't find references forced or creepy
Memory utilization: >40% of responses include relevant recalls


2.2 Contradiction Detection
What It Does:

Identifies when users' actions contradict stated values/goals
Detects cognitive distortions (all-or-nothing thinking, catastrophizing)
Gently points out gaps between intention and behavior

Detection Service:
typescript// server/services/contradictionDetectionService.ts

interface Belief {
  id: string;
  userId: string;
  statement: string;
  category: 'value' | 'goal' | 'identity' | 'preference' | 'intention';
  confidence: number; // How strongly they've expressed this
  firstStated: Date;
  lastConfirmed: Date;
  contradictingActions: string[];
}

interface Contradiction {
  beliefId: string;
  belief: string;
  contradictingStatement: string;
  contradictionType: 'action-value' | 'goal-behavior' | 'identity-action' | 'cognitive-distortion';
  severity: 'low' | 'medium' | 'high';
  detectedAt: Date;
  shouldMention: boolean;
}

export class ContradictionDetectionService {
  // Extract beliefs from conversations
  async extractBeliefs(message: string, userId: string): Promise<Belief[]> {
    const analysis = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [{
        role: "system",
        content: `Identify beliefs, values, goals, or intentions in this message.
        Extract statements like:
        - "I want to be more present with my family" (intention)
        - "Authenticity is really important to me" (value)
        - "I'm trying to set better boundaries" (goal)
        - "I'm not a creative person" (identity belief)
        
        Return as JSON array with: statement, category, confidence (0-1)`
      }, {
        role: "user",
        content: message
      }]
    });

    const extracted = JSON.parse(analysis.choices[0].message.content);
    return extracted.map(b => ({
      ...b,
      userId,
      firstStated: new Date(),
      lastConfirmed: new Date(),
      contradictingActions: []
    }));
  }

  // Check for contradictions
  async detectContradictions(
    userId: string,
    currentMessage: string
  ): Promise<Contradiction[]> {
    // Get user's established beliefs
    const beliefs = await db.select()
      .from(beliefsTable)
      .where(eq(beliefsTable.userId, userId))
      .where(gt(beliefsTable.confidence, 0.6)); // Only well-established beliefs

    const contradictions: Contradiction[] = [];

    for (const belief of beliefs) {
      const analysis = await openai.chat.completions.create({
        model: "gpt-4",
        messages: [{
          role: "system",
          content: `Does this current message contradict or conflict with this belief?
          
          Belief: "${belief.statement}"
          Current message: "${currentMessage}"
          
          Analyze if there's a contradiction. Consider:
          - Action-value misalignment (saying X is important but doing opposite)
          - Goal-behavior conflict (stating goal but describing avoidance)
          - Identity-action mismatch (defining self one way but acting differently)
          - Cognitive distortions (all-or-nothing, catastrophizing, etc.)
          
          Return JSON: { 
            isContradiction: boolean,
            contradictionType: string,
            explanation: string,
            severity: 'low'|'medium'|'high',
            shouldMention: boolean (gentle pointer, not accusation)
          }`
        }]
      });

      const result = JSON.parse(analysis.choices[0].message.content);

      if (result.isContradiction && result.shouldMention) {
        contradictions.push({
          beliefId: belief.id,
          belief: belief.statement,
          contradictingStatement: currentMessage,
          contradictionType: result.contradictionType,
          severity: result.severity,
          detectedAt: new Date(),
          shouldMention: true
        });
      }
    }

    return contradictions;
  }

  // Detect cognitive distortions
  async detectCognitiveDistortions(message: string): Promise<CognitiveDistortion[]> {
    const distortionTypes = [
      'all-or-nothing thinking',
      'overgeneralization',
      'mental filter (focusing only on negatives)',
      'discounting the positive',
      'jumping to conclusions',
      'catastrophizing',
      'emotional reasoning',
      'should statements',
      'labeling',
      'personalization'
    ];

    const analysis = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [{
        role: "system",
        content: `Identify cognitive distortions in this message:
        ${distortionTypes.map((d, i) => `${i + 1}. ${d}`).join('\n')}
        
        Return JSON array of any distortions found with:
        - type: which distortion
        - evidence: the specific phrase/thought
        - alternativePerspective: a gentler reframe`
      }, {
        role: "user",
        content: message
      }]
    });

    return JSON.parse(analysis.choices[0].message.content);
  }
}
Gentle Contradiction Pointing:
typescript// When Bliss detects contradiction, respond thoughtfully
function formatContradictionResponse(contradiction: Contradiction): string {
  const gentle = [
    `I'm noticing something... `,
    `Can I point out something I'm observing? `,
    `I want to mention something gently... `,
    `This might be worth reflecting on... `
  ];

  const templates = {
    'action-value': `${gentle[0]}You've shared that ${contradiction.belief}, but ${contradiction.contradictingStatement}. I'm curious about that gapâ€”what do you think is making it hard to align your actions with what matters to you?`,
    
    'goal-behavior': `${gentle[1]}You mentioned wanting to ${contradiction.belief}, and I believe you mean that. But I also heard you describe ${contradiction.contradictingStatement}. Sometimes there are invisible barriers between our intentions and actions. What do you think might be in the way?`,
    
    'cognitive-distortion': `${gentle[2]}I'm hearing some pretty harsh self-talk in what you just said. Words like "always" and "never" can make things feel more absolute than they are. Is it really true that this is *always* the case, or might there be some nuance there?`
  };

  return templates[contradiction.contradictionType] || templates['action-value'];
}
Example User Experience:
User: "I really want to be more authentic and vulnerable with people."
[2 weeks later]
User: "I went to that party and just put on my happy face like always. 
      Didn't want to burden anyone with my stress."

Bliss: "I'm noticing something... Two weeks ago you shared such a 
beautiful intention about being more vulnerable and authentic with 
people. But when you describe the party, it sounds like you did the 
oppositeâ€”you hid what you were really feeling. I'm not judging, I'm 
just curious: what made it hard to show up authentically in that 
moment? What were you protecting yourself from?"
Safety Mechanisms:
typescript// Don't mention every contradictionâ€”be selective
function shouldMentionContradiction(
  contradiction: Contradiction,
  userHistory: UserContext
): boolean {
  // Don't overwhelm with contradictions
  const recentContradictionMentions = userHistory.contradictionMentionsLastWeek;
  if (recentContradictionMentions > 2) return false;

  // Only mention high-severity or repeated patterns
  if (contradiction.severity === 'low') return false;

  // Check if user is in fragile emotional state
  const recentEmotion = userHistory.lastEmotionalState;
  if (recentEmotion.valence < -0.6) return false; // Too vulnerable right now

  // Check if this is a recurring pattern worth addressing
  const similarContradictions = userHistory.contradictionHistory.filter(
    c => c.beliefId === contradiction.beliefId
  );
  if (similarContradictions.length < 2) return false; // Wait for pattern

  return true;
}
Success Metrics:

Contradiction detection accuracy: >80%
User receptiveness: <10% negative reactions to contradiction pointing
Growth impact: Track if pointing out contradictions leads to positive changes

